using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class PhysicsSimulation : MonoBehaviour
{
  public int maxIterations = 1000;
  private PhysicsSimulation.SimulatedBody[] simulatedBodies;
  public Vector2 forceMinMax;
  public float forceAngleInDegrees;
  public bool randomizeForceAngle;
  private List<Rigidbody> generatedRigidbodies;
  private List<Collider> generatedColliders;

  [ContextMenu("Run Simulation")]
  public void RunSimulation()
  {
    this.AutoGenerateComponents();
    this.simulatedBodies = ((IEnumerable<Rigidbody>) UnityEngine.Object.FindObjectsOfType<Rigidbody>()).Select<Rigidbody, PhysicsSimulation.SimulatedBody>((Func<Rigidbody, PhysicsSimulation.SimulatedBody>) (rb => new PhysicsSimulation.SimulatedBody(rb, rb.transform.IsChildOf(this.transform)))).ToArray<PhysicsSimulation.SimulatedBody>();
    foreach (PhysicsSimulation.SimulatedBody simulatedBody in this.simulatedBodies)
    {
      if (simulatedBody.isChild)
      {
        float num = UnityEngine.Random.Range(this.forceMinMax.x, this.forceMinMax.y);
        float f = (float) ((this.randomizeForceAngle ? (double) UnityEngine.Random.Range(0.0f, 360f) : (double) this.forceAngleInDegrees) * (Math.PI / 180.0));
        Vector3 vector3 = new Vector3(Mathf.Sin(f), 0.0f, Mathf.Cos(f));
        simulatedBody.rigidbody.AddForce(vector3 * num, ForceMode.Impulse);
      }
    }
    Physics.autoSimulation = false;
    for (int index = 0; index < this.maxIterations; ++index)
    {
      Physics.Simulate(Time.fixedDeltaTime);
      if (((IEnumerable<PhysicsSimulation.SimulatedBody>) this.simulatedBodies).All<PhysicsSimulation.SimulatedBody>((Func<PhysicsSimulation.SimulatedBody, bool>) (body => body.rigidbody.IsSleeping() || !body.isChild)))
        break;
    }
    Physics.autoSimulation = true;
    foreach (PhysicsSimulation.SimulatedBody simulatedBody in this.simulatedBodies)
    {
      if (!simulatedBody.isChild)
        simulatedBody.Reset();
    }
    this.RemoveAutoGeneratedComponents();
  }

  private void AutoGenerateComponents()
  {
    this.generatedRigidbodies = new List<Rigidbody>();
    this.generatedColliders = new List<Collider>();
    foreach (Transform transform in this.transform)
    {
      if (!(bool) (UnityEngine.Object) transform.GetComponent<Rigidbody>())
        this.generatedRigidbodies.Add(transform.gameObject.AddComponent<Rigidbody>());
      if (!(bool) (UnityEngine.Object) transform.GetComponent<Collider>())
        this.generatedColliders.Add((Collider) transform.gameObject.AddComponent<BoxCollider>());
    }
  }

  private void RemoveAutoGeneratedComponents()
  {
    foreach (UnityEngine.Object generatedRigidbody in this.generatedRigidbodies)
      UnityEngine.Object.DestroyImmediate(generatedRigidbody);
    foreach (UnityEngine.Object generatedCollider in this.generatedColliders)
      UnityEngine.Object.DestroyImmediate(generatedCollider);
  }

  [ContextMenu("Reset")]
  public void ResetAllBodies()
  {
    if (this.simulatedBodies == null)
      return;
    foreach (PhysicsSimulation.SimulatedBody simulatedBody in this.simulatedBodies)
      simulatedBody.Reset();
  }

  private struct SimulatedBody
  {
    public readonly Rigidbody rigidbody;
    public readonly bool isChild;
    private readonly Vector3 originalPosition;
    private readonly Quaternion originalRotation;
    private readonly Transform transform;

    public SimulatedBody(Rigidbody rigidbody, bool isChild)
    {
      this.rigidbody = rigidbody;
      this.isChild = isChild;
      this.transform = rigidbody.transform;
      this.originalPosition = rigidbody.position;
      this.originalRotation = rigidbody.rotation;
    }

    public void Reset()
    {
      this.transform.position = this.originalPosition;
      this.transform.rotation = this.originalRotation;
      if (!((UnityEngine.Object) this.rigidbody != (UnityEngine.Object) null))
        return;
      this.rigidbody.velocity = Vector3.zero;
      this.rigidbody.angularVelocity = Vector3.zero;
    }
  }
}
